#!/usr/bin/perl

##############################################################################
# $Id: rrdwattsond,v 0.8 2012/05/06 10:13:05 goblet Exp $
##############################################################################
#  
#                 rrdwattsond - DIY Kyoto Wattson daemon
#
# Mikko Pikarinen 2011-2012
#
# This program is beerware. If you like it, buy me a beer if we meet some day.
#  
# Sorry, the code is not so well commented, but for any perl coder it should 
# be quite self explanatory.
#
# Extra Ubuntu-packages needed: libdate-calc-perl rrdtool librrds-perl
##############################################################################

use strict;
use POSIX;
use RRDs;
use Time::HiRes;
use Time::Local;
use Date::Calc;

# ----------------------------------------------------------------------------
# STTY settings 
my $stty = "5:0:8be:0:0:0:0:0:0:a". ":0" x 26;

# default config
my $config = {
    # serial port of wattson
    'port' => '/dev/ttyUSB0',
    # interval to check power for getting max and min
    'interval' => 3,
    'rrd' => 'wattson.rrd',
    'workdir' => '/var/rrdwattsond',
    'pidfile' => "/var/rrdwattsond/wattsond.pid"
};

my $time_to_die = 0;
my $debug = 0;
my $opts = getopt();
my $VERSION = '$Revision: 0.8 $';
$VERSION =~ s/[^\d\.]//g;
$SIG{TERM} = sub {$time_to_die++};
$SIG{HUP} = sub {read_config()};

# ----------------------------------------------------------------------------
# Read command line parameters to a hash

sub getopt {
    my $i = 0;
    my ($ret) = {};
    while ($i < $#ARGV+1) {
        if ($ARGV[$i] =~ /^-/) {
            if ($ARGV[$i+1] =~ /^-/ || $i == $#ARGV) {
                $ret->{substr($ARGV[$i],1)} = 1;
            } else {
                $ret->{substr($ARGV[$i++],1)} = $ARGV[$i+1];
            }
        }
        $i++;
    }
    return $ret;
}
# ----------------------------------------------------------------------------
# Read config file

sub read_config($) {
    my $conffile = shift;

    if ( !-e $conffile ) {
        foreach my $f ("/etc/rrdwattsond.conf","rrdwattsond.conf") {
            if ( -e $f ) {$conffile = $f; last}
        }
    }

    open FD, "<$conffile" or return undef;
    my @rows = <FD>;
    close FD;

    foreach my $row (@rows) {
        $row =~ s/^\s*//;
        next if ($row =~ /^([;#]|$)/);
        $row =~ s/[\r\n]//g;
        my ($key,$val) = split(/=/,$row,2);
        $key =~ s/\s*$//;
        $val =~ s/^\s*//;
        $val =~ s/\s*$//;
        $config->{$key} = $val;
    }
}

# ----------------------------------------------------------------------------
# Send a command to Wattson. See protocol.txt document for details.

sub wattson_cmd($) {
    my $cmd = shift;
    my $port = $config->{'port'};
    my $ret;
    my $io;

    open $io, "+<$port" or do {
         print STDERR "Error trying to open $port: $!\n";
         return undef;
    };

    # flush everything to be sure
    POSIX::tcflush($io,TCIOFLUSH);

    print $io $cmd."\r";

    # Max 5 retries to get data. 
    # If no response, sleep 0.1 seconds and try again
    for (my $i = 0; $i < 5; $i++) {
        if (defined(read($io,$ret,256))) {
            close $io;
            $ret =~ s/\r(.*|$)//;
            chomp $ret;
            # cut the first char from response because we know it already
            printf("retval from cmd %s: %s\n", $cmd, substr($ret,1)) if ($debug);
            return substr($ret,1);
        }
        Time::HiRes::usleep(100000);
    }

    close $io;
    return undef;
}
# ----------------------------------------------------------------------------
# Read a memory slot from Wattson. See protocol.txt
# Parameters: daysago (yesterday = 1, today = 0), then hour and minute

sub get_mem_slot($$$) {
    my ($daysago,$hour,$min) = @_;

    my $dayslots = hex(wattson_cmd("nowd")) + 1;
    my $dayslot = $dayslots - $daysago;
    printf("dayslots: %02d, dayslot: %02d\n", $dayslots, $dayslot) if ($debug);

    my $hourslot = int($hour/2)+1;
    if ($min == 0 and $hour % 2 == 0) {$hourslot--};
    if ($hourslot == 0) {$hourslot = 12; $dayslot--}
    if ($dayslot < 1) {return undef}

    my $cmd = sprintf("nowl%02d%02d",$dayslot,$hourslot);
    printf("nowl%02d%02d",$dayslot,$hourslot) if ($debug);
    return wattson_cmd($cmd);
}
# ----------------------------------------------------------------------------
# Get watts value for minute from slot that we got by get_mem_slot()
# The minute value must be divideable by 5 as the data is saved.

sub get_watts_from_slot($$) {
    my ($minute,$slot) = @_;
    if ($minute % 5 != 0) {return undef}
    my @data = split(",",$slot);
    my $index = $minute / 5 -1;
    if ($index == -1) {$index = 23}
    return hex($data[$index]);
}
# ----------------------------------------------------------------------------
# Calculate kWh from downloaded day data

sub count_kwh {
    my $daydata = shift;
    my @data = split("\n",$daydata);

    my $sum = 0;
    foreach my $i (@data) {
        my @row = split(",",$i);
        pop @row;
        foreach my $j (@row) {
            $sum += hex($j)/12;
        }
    }
    return sprintf("%.3f",$sum/1000);
}
# ----------------------------------------------------------------------------
# Do the midnight tasks. Download yesterday, save it to a file named
# energydata.YYYYMMDD, get calculated kWh, save it to kwh.csv 
# and finally clear storage if everything went ok.

sub midnight_task {
    my @t = localtime();
    my ($y,$m,$d) = Date::Calc::Add_Delta_Days($t[5]+1900,$t[4]+1,$t[3],-1);
    my $yesterday = sprintf("%04d%02d%02d",$y,$m,$d);
    if ( -e "energydata.".$yesterday ) {
        return 1;
    }
    my $ydslot = hex(wattson_cmd("nowd"));
    if (length($ydslot) != 2 or $ydslot eq "00") {return 0}

    my $daydata = "";
    my $retryfail = 0;
    for (my $i = 1; $i < 13; $i++) {
         my $slot = wattson_cmd(sprintf("nowl%s%02d",$ydslot,$i));
         if ($slot) {
             $daydata .= $slot."\n";
         } else {
             $retryfail++;
             Time::HiRes::usleep(100000);
         }
         if ($retryfail > 60) {return 0;}
    }
    print length($daydata);
    # data length must be 1476 bytes if everything went right
    if (length($daydata) == 1476) {
        open FD, ">energydata.".$yesterday;
        print FD $daydata;
        close FD;
        my $kwh = count_kwh($daydata);
        my $logrow = sprintf("%04d-%02d-%02d,%s\n",$y,$m,$d,$kwh);
        open FD, ">>kwh.csv";
        print FD $logrow;
        close FD;
        # clear storage only if we succeeded on 00:00 otherwise do it tomorrow
        if ($t[1] < 5) {wattson_cmd("nowE")}
    }
    return 1;
}
# ----------------------------------------------------------------------------
# Read all possible saved data from Wattson and feed them to RRD if needed.
# This is good on first start or if the daemon hasn't been running for a while

sub update_from_past {
    my $firsttime = shift;

    print "$firsttime,". time() ."\n" if ($debug);
    while ($firsttime < time()) {
        my @t = localtime();
        my @rt = localtime($firsttime);
        my $daydiff = Date::Calc::Delta_Days($t[5]+1900,$t[4]+1,$t[3],
                                     $rt[5]+1900,$rt[4]+1,$rt[3]);

        my $slot = get_mem_slot(abs($daydiff),$rt[2],$rt[1]);
        my @data = split(",",$slot);
        pop @data;

        @rt[2] = int($rt[2]/2)*2;
        $rt[1] = $rt[0] = 0;
        my $start = $firsttime;
        foreach my $i (@data) {
             $start += 300;
             last if ($start >= time() or hex($i) > 0xFF00);
             if ($start > $firsttime) {
                 print scalar localtime($start) ." ". hex($i) if ($debug);
                 printf("call RRDs::update") if ($debug);
                 RRDs::update($config->{'rrd'},$start.":U:".hex($i).":U");
                 print RRDs::error ."\n" if ($debug);
             }
        }
        $firsttime += 7200;
    }
}
# ----------------------------------------------------------------------------
# Synchronize Wattson's clock from the computer.

sub clock_sync {
    my @t = localtime();
    my $now = sprintf("%02d/%02d/%02d %02d:%02d:%02d",
                  $t[5]%100,$t[4]+1,$t[3],$t[2],$t[1],$t[0]);
    wattson_cmd("nowT".$now);
}
# ----------------------------------------------------------------------------
# Initializing on startup

sub initialize {

    print "rrdwattsond $VERSION\n";
    # Set STTY
    qx{/bin/stty -F $config->{'port'} $stty};

    chdir $config->{'workdir'} or do {
        print "cannot chdir to workdir ".$config->{'workdir'}."\n";
        exit(1);
    };
    my $data = wattson_cmd("nows");
    if ($data) {
        print "Wattson found serial $data\n";
    } else {
       print STDERR "Error communication to wattson.\n";
       exit(1);
    }
    $data = wattson_cmd("nowt");
  
    my @t = localtime();
    my $now = sprintf("%02d/%02d/%02d %02d:%02d:%02d",
                  $t[5]%100,$t[4]+1,$t[3],$t[2],$t[1],$t[0]);

    if ($now ne $data) {
        print "device clock $data, computer clock $now\n";
        print "syncing clocks.\n";
        wattson_cmd("nowT".$now);
    } else {
        print "device clock == computer clock: $data\n";
    }

    my @foo=reverse(split(/[^\d]/,$data));
    my $stored_days = hex(wattson_cmd("nowd"));
    my ($y,$m,$d) = Date::Calc::Add_Delta_Days(
                     $foo[5],$foo[4],$foo[3],0-$stored_days);

    my $rrdlast = RRDs::last($config->{'rrd'});
    my $wattsonmin = Time::Local::timelocal(0,0,0,$d,$m-1,$y);

    # if last rrd update is older than oldest data in the device
    if ($wattsonmin > $rrdlast) {
        $rrdlast = $wattsonmin;
    }

    # If the RRD has not been updated in over 5 minutes, update from 
    # Wattson's memory if possible.
    printf("check if should call update_from_past\n") if ($debug);
    if (time() - $rrdlast > 300) {
        printf("do update_from_past\n") if ($debug);
        update_from_past($rrdlast);
    }
 
    return 1;
}
# ----------------------------------------------------------------------------
# Main function

sub main {
    my $min = 99999;
    my $max = 0;
    my $cleared = 0;
    
    my $conffile = undef;

    if ($opts->{'c'}) {$conffile = $opts->{'c'}}
    if ($opts->{'d'}) {$debug = 1}

    read_config($conffile);
    initialize();

    # Fork to background
    my $pid = fork();
    if($pid) {
        print "forked with pid $pid\n";
        open FD, ">".$config->{'pidfile'};
        print FD $pid."\n";
        close FD;
        return 0;
    }
    die "Couldn't fork: $!" unless defined($pid);
    POSIX::setsid() or die "Can't start a new session: $!";

    close STDIN;
    open STDIN, "</dev/null" or die $!;
    if (!$debug) {
        close STDOUT;
        open STDOUT, ">/dev/null" or die $!;
        close STDERR;
        open STDERR, ">/dev/null" or die $!;
    }

    # mainloop
    while (!$time_to_die) {
        my @t = localtime();
        my $power = wattson_cmd("nowp");
        if (defined($power)) {
            $power =~ s/^p//;
            if (length($power) == 4) {
                $power = hex($power);
                if ($power < $min) {$min = $power}
                if ($power > $max) {$max = $power}
            }
        }
        printf("%02d%02d%02d %d",$t[2],$t[1],$t[0],$power) if ($debug);
        print " min: $min, max: $max\n" if ($debug);

        # Update RRD and do the other tasks if minutes are *5 or *0
        if ($t[1] % 5 == 0) {
            # we did this already on current minute?
            if ($cleared == 0) {
                $cleared = 1;
                my $slot = get_mem_slot(0,$t[2],$t[1]);
                print "get_mem_slot(0,$t[2],$t[1]):$slot\n" if ($debug);
                my $m = $t[1];
                if ($t[2] % 2 == 1) {$m += 60}
                my $avg = get_watts_from_slot($m,$slot);
                if ($min == 99999) {$min = "U"}
                if ($max < 1) {$max = "U"}
                printf("update %02d%02d%02d min %d avg %d max %d\n",
                        $t[2],$t[1],0,$min,$avg,$max) if ($debug);

                # save to rrd if avg is between min and max
                my $ts = Time::Local::timelocal(0,$t[1],$t[2],$t[3],$t[4],$t[5]);
                if ($min <= $avg and $avg <= $max) {
                    printf("call RRDs::update") if ($debug);
                    RRDs::update($config->{'rrd'},"$ts:$min:$avg:$max");
                    
                    # sync clock every day at 00:05
                    if ($t[2] == 0 && $t[1] == 5) {
                        clock_sync();
                    }
                    # Do the midnight task on first hour of the day
                    # If it fails, this will try to do the task on every 5min
                    # run from 00 to 01
                    if ($t[2] == 0) {
                        midnight_task();
                    }
                }
                $min = 99999; $max = 0;
            } else {
                sleep($config->{interval} -1);
            }
        } else {
            sleep($config->{interval} -1);
            $cleared = 0;
        }
    } # mainloop end
    unlink $config->{'pidfile'};
    return 0;
}
# ----------------------------------------------------------------------------
exit main();
# ----------------------------------------------------------------------------
